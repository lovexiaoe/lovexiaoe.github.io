---
title: 系统硬件组成
published: false
category: computer-system
---

### 典型的硬件结构
一个典型的硬件结构如下：        
![](/assets/computersystem/hardware-organization-1.png)     

* Buses     
贯穿整个系统的是一组称为总线的电线管，在各个组件之间传递信息。总线一般传递固定大小的字节。被称为`words`，`words`的字节数是一个基本的系统参数。
今天的大多数是4字节或者8字节。        
* I/O Devices       
IO设备用于连接外部世界，如键盘，鼠标。每个I/O设备通过控制器或适配器连接到I/O总线。控制器和适配器的区别主要是包装上的区别，控制器是设置在设备本身
或者主板上的芯片，适配器是插在主板上一个插槽中的卡片。控制器和适配器的主要作用是在IO总线和IO设备之间传递信息。       
* Main Memory       
内存被组织成字节的线性数组。      
* 处理器       
处理器主要有3个部分：PC(program counter),Register file,ALU(Arithmetic/Logic Unit)。其核心是寄存器，也被称为program counter(PC)。
PC始终指向某些在主内存中的机器语言指令。处理器一直重复动作：执行PC执行的机器指令， 并更新PC指向下一个指令。寄存器文件（Register file）是由一组
`words`组成的小型存储设备。每个寄存器文件都有唯一的名称。下面是CPU在执行指令时，可能运行的动作：       
    1. Load:从主内存copy一个字节或者`word`到寄存器，覆盖寄存器之前的内容。
    1. Store:从寄存器copy一个字节或者`word`到主内存，覆盖主内存那个位置之前的内容。
    1. Operate:copy两个寄存器中的内容到ALU，将两个`word`执行算数运算。将运算结果存储到某个寄存器中。覆盖这个寄存器之前的内容。
    1. Jump:从指令本身中提取一个`word`并copy到PC中，覆盖PC之前的值。     

### 缓存处理
把信息从一个地方移动到另一个地方，系统需要花大量的时间。程序的机器指令时存放在磁盘中的，当程序被加载时，它们会被copy到主内存中。如下图黑线箭头所示：        
![](/assets/computersystem/recipe1/cache-1.png)     
将字符串从内存输出到显示器，如下图黑线箭头所示：        
![](/assets/computersystem/recipe1/cache-2.png)     
各个类型的存储设备，访问速度差别很大，大存储设备比更小的存储设备更慢。快的存储设备更加昂贵。如磁盘比内存大千倍不止，但是访问速度比内存慢成千上万倍。
类似地，通常寄存器文件只存储几百或几千字节的信息。而内存可以存储更多的的信息，但是寄存器文件的读取时内存文件的百倍。随着技术的更新，寄存器和内存
之间的读取速度差距还在持续增加。为了处理这种差距，引入了缓存，作为处理器对将来可能处理的数据进行临时暂存的区域。如下图：        
![](/assets/computersystem/recipe1/cache-3.png)     
L1和L2缓存使用static random access memory(SRAM)的硬件技术。新的计算机和系统甚至有3级缓存。

### 操作系统管理硬件
操作系统是连接软件和硬件的桥梁，有两个主要的目的，1：保护硬件被失控的应用滥用；2：管理复杂和截然不同的低层硬件设备，为应用提供统一且简单的操作机制。
为达到这两个目的，操作系统提供了三个基本的抽象，1：文件：是IO设备的抽象；2：虚拟内存：是主内存和IO设备两者的抽象；3：进程：是主内存，IO设备，
处理器三者的抽象。如下图所示：     
![](/assets/computersystem/recipe1/OS-1.png)        

#### 进程
进程是OS对一个运行中的程序的抽象，程序就好像运行在独立的处理器，主内存和IO设备中。传统的系统在一个时间只能运行一个程序，而现在的多核处理器可以同时
执行多个程序。操作系统通过上下文切换的机制实现这种能力。        
进程运行需要的状态信息被称为上下文，如当前Program Counter中的值。寄存器文件，主内存中的内容等。当操作系统决定从当前进程转移到其他进程时，会保存
当前进程的上下文，恢复新进程的上下文。将控制权移交给新进程。如下图展示了两个进程之间的切换流程：        
![](/assets/computersystem/recipe1/process-switch.png)      
进程之间的转移是由操作系统的kernel管理的，kernel是一堆常驻内存的代码和数据结构，不是一个进程，用于管理所有的进程，如读取文件等。

#### 线程
现代系统中，一个进程由多个执行单元组成，称为线程。每个线程运行在进程上下文中，并共享全局数据。线程间可以共享数据。比进程更高效。

#### 虚拟内存
虚拟内存被所有用户占用，linux的虚拟内存视图如下：     
![](/assets/computersystem/recipe1/virtual-memory-1.png)        
地址的最高区域为操作系统的代码和数据保留，较低的地址空间为用户进程的代码和数据占用。自下而上共可以分为下面几个部分：
* 程序代码和数据：代码和数据区域直接从可执行文件的内容中加载数据。
* 堆：运行时堆，在进程开始运行后，大小是固定的。C的动态扩展和收缩是通过调用标准库的malloc和free方法。
* 栈：用户栈用户执行方法调用，在执行程序时可动态扩张或者收缩，每次调用一个方法，栈会扩张，相反，返回一个函数，栈会收缩。
* Kernel 虚拟内存： 为内核预留，应用程序不能调用，必须通过调用内核执行相关操作。

### 重要的概念
1. 阿姆达尔定律       
阿姆达尔是早期的计算机工程师，制定了一个提升某个组件对整体系统提升程度的计算公式。其核心思路是，系统整体性能的提升依赖你提升的这个组件部分在整体系统
中有多重要。假如，提升前系统执行一个程序需要的时间为Told,某个组件需要的时间占的比例为α，我们对这个组件的提升倍数为k，那么现在这个组件运行花的
时间为`(αTold)/k`。提升后系统新的执行时间为
```
Tnew = (1 − α)Told + (αTold)/k = Told[(1 − α) + α/k]
```
那么系统的加速率 `Told/Tnew`为：
```
S = 1/((1-α)+α/k)
```

2. 多核处理器
现代的多处理器CPU一般有多个核和超线程特性，如下图：
![](/assets/computersystem/recipe1/multiprocessors-1.png)       
![](/assets/computersystem/recipe1/multiprocessors-2.png)       
超线程，也被称为同时多线程。是允许单个CPU执行多个控制流程的技术。I7处理器每个核心可以处理两个线程，所以一个四核系统可以同时又8个线程并行。

